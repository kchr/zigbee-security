#!/usr/bin/env python

'''
Simple script to send/receive long packets of bytes with incremented values.
Useful for debugging/tool development.
For use with KillerBee library.
2012 rmspeers
'''

import sys
import os
import signal
import time

from killerbee import *

txcount = rxcount = seqnum = 0

def show_dev():
    print "Dev\tProduct String\tSerial Number"
    for dev in kbutils.devlist():
        print "%s\t%s\t%s" % (dev[0], dev[1], dev[2])

def interrupt(signum, frame):
    global txcount
    global rxcount
    global arg_recv
    global kb
    kb.close()
    if arg_recv:
        print "\n%d packets received." % (rxcount)
    else:
        print "\n%d packets transmitted." % (txcount)
    sys.exit(0)

def usage():
    print """zbtestpkts: Send or receive packets in a known pattern, intended for testing and tool development.
 (2012 rmspeers)

Options:
  -c channel: tx/rx on given channel (default 11)
  -i USB ID | Serial Device Path: use given device
  -s seconds: if tx, wait given seconds between packet injections (default 2)
  -l length: if tx, send packets with main body of the given length (default 50)
  -r: receive packets, and compare them to the expected values to detect alteration
  -R: list KillerBee devices connected, and exit
  -h: show this help, and exit"""

if __name__ == '__main__':
    # Command-line arguments
    arg_devstring = None
    arg_delay = None
    arg_channel = None
    arg_length = None
    arg_recv = False

    while len(sys.argv) > 1:
        op = sys.argv.pop(1)
        if op == '-i':
            arg_devstring = sys.argv.pop(1)
        if op == '-s':
            arg_delay = float(sys.argv.pop(1))
        if op == '-l':
            arg_length = int(sys.argv.pop(1))
        if op == '-c':
            arg_channel = int(sys.argv.pop(1))
        if op == '-r':
            arg_recv = True
        if op == '-D':
            show_dev()
            sys.exit(0)
        if op == '-h':
            usage()
            sys.exit(0)

    signal.signal(signal.SIGINT, interrupt)

    # Validate command line options and set defaults    
    if arg_recv:
        if arg_delay: raise Exception("Can't use delay option when receiving.")
        if arg_length: raise Exception("Can't use length option when receiving.")

    if arg_channel:
        channel = arg_channel
    else:
        channel = 11

    if not arg_length:
        arg_length = 70
    elif arg_length >= 255:
        raise Exception("Length of packet must not be greater than 255 bytes.")

    if not arg_delay:
        arg_delay = 2
    
    kb = KillerBee(device=arg_devstring)
    kb.set_channel(channel)

    print "zbtestpkts: %s on interface \'%s\'" % \
          ("Receiving" if arg_recv else "Transmitting", kb.get_dev_info()[0])
    
    # Create the default frame we will be testing with (will add seqnums later):
    injframe = ''.join(["%c"%num for num in range(arg_length)])
    
    # Loop receiving packets, if instructed by arg_recv == True:
    while arg_recv:
        packet = kb.pnext()
        if packet != None:
            rxcount+=1
            print packet['bytes'].encode('hex')
            compbytes = packet['bytes'][1:-3] #cut off seq nums and FCSs
            if compbytes != injframe:
                print " > Variation from expected frame contents."
                for i in range(len(compbytes)):
                    if compbytes[:i] != injframe[:i]:
                        print " > Variation occurs at byte %d." % i
                        break
    
    # If not set to receive, we fall through to here.
    # Loop injecting packets:
    while 1:
        if seqnum > 255:
            print " > Wrapping around sequence number."
            seqnum = 0
        # Transmitted frame is: SEQNUM / Bytes 0x00 -> arg_length / SEQNUM / FCS
        injbytes = "%c"%seqnum + injframe + "%c"%seqnum
        print "Sending:", injbytes.encode('hex')
        try:
            kb.inject(injbytes)
            txcount += 1
            seqnum += 1
        except Exception, e:
            print "ERROR: Unable to inject packet:", e
            sys.exit(-1)
        if arg_delay:
            time.sleep(arg_delay)
